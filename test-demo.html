<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaiNecklace Service Test</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .subtitle {
            color: #888;
            font-size: 14px;
        }
        .section {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #444;
        }
        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
        }
        .button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: bold;
        }
        .button:hover {
            background: #0056b3;
        }
        .button.success {
            background: #28a745;
        }
        .result {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            margin-top: 12px;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .input {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            color: #ffffff;
            width: 100%;
            margin-bottom: 12px;
            box-sizing: border-box;
        }
        .status {
            color: #888;
            font-style: italic;
            margin-bottom: 12px;
        }
        .note {
            color: #666;
            font-size: 12px;
            line-height: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">üéôÔ∏è TaiNecklace Service Test</div>
            <div class="subtitle">Testing Core Functionality</div>
        </div>

        <div class="section">
            <div class="section-title">Status</div>
            <div class="status">Ready to test services</div>
            <div class="note">
                ‚ÑπÔ∏è This tests the same ADPCM decoder and transcription services used in the mobile app.
            </div>
        </div>

        <div class="section">
            <div class="section-title">AssemblyAI Configuration</div>
            <input type="password" id="apiKey" class="input" placeholder="Enter AssemblyAI API Key" />
            <button class="button success" onclick="saveApiKey()">Save API Key</button>
        </div>

        <div class="section">
            <div class="section-title">Service Testing</div>
            <button class="button" onclick="testADPCM()">üîä Test ADPCM Decoder</button>
            <button class="button success" onclick="testTranscription()">üß† Test Transcription Service</button>
            <div id="testResults"></div>
        </div>

        <div class="section">
            <div class="section-title">Next Steps</div>
            <div class="note">
                1. Test services here ‚úÖ<br>
                2. For mobile BLE testing: Use Expo Go app to scan QR code<br>
                3. For production XIAO testing: Build production React Native app<br><br>
                üì± <strong>Mobile App Status:</strong> React Native app is ready with BLE support for XIAO device connection.
            </div>
        </div>
    </div>

    <script>
        // ADPCM Decoder Implementation
        class ADPCMDecoder {
            static STEP_TABLE = [
                7, 8, 9, 10, 11, 12, 13, 14,
                16, 17, 19, 21, 23, 25, 28, 31,
                34, 37, 41, 45, 50, 55, 60, 66,
                73, 80, 88, 97, 107, 118, 130, 143,
                157, 173, 190, 209, 230, 253, 279, 307,
                337, 371, 408, 449, 494, 544, 598, 658,
                724, 796, 876, 963, 1060, 1166, 1282, 1411,
                1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,
                3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,
                7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,
                15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
            ];

            static INDEX_TABLE = [
                -1, -1, -1, -1, 2, 4, 6, 8,
                -1, -1, -1, -1, 2, 4, 6, 8
            ];

            constructor() {
                this.predictor = 0;
                this.stepIndex = 0;
            }

            decodeSample(adpcmSample) {
                let step = ADPCMDecoder.STEP_TABLE[this.stepIndex];
                let diff = step >> 3;
                
                if (adpcmSample & 1) diff += step >> 2;
                if (adpcmSample & 2) diff += step >> 1;
                if (adpcmSample & 4) diff += step;
                
                if (adpcmSample & 8) {
                    this.predictor -= diff;
                } else {
                    this.predictor += diff;
                }
                
                if (this.predictor > 32767) this.predictor = 32767;
                if (this.predictor < -32768) this.predictor = -32768;
                
                this.stepIndex += ADPCMDecoder.INDEX_TABLE[adpcmSample];
                if (this.stepIndex < 0) this.stepIndex = 0;
                if (this.stepIndex >= ADPCMDecoder.STEP_TABLE.length) this.stepIndex = ADPCMDecoder.STEP_TABLE.length - 1;
                
                return this.predictor;
            }

            decodeBlock(adpcmData) {
                if (!adpcmData || adpcmData.length === 0) {
                    return [];
                }
                
                const pcmSamples = new Array(adpcmData.length * 2);
                let pcmIndex = 0;
                
                for (let i = 0; i < adpcmData.length; i++) {
                    const byte = adpcmData[i];
                    const sample1 = (byte >> 4) & 0x0F;
                    const sample2 = byte & 0x0F;
                    
                    pcmSamples[pcmIndex++] = this.decodeSample(sample1);
                    pcmSamples[pcmIndex++] = this.decodeSample(sample2);
                }
                
                return pcmSamples;
            }

            reset() {
                this.predictor = 0;
                this.stepIndex = 0;
            }
        }

        // Transcription Service
        class TranscriptionService {
            constructor(apiKey) {
                this.apiKey = apiKey;
                this.baseUrl = 'https://api.assemblyai.com/v2';
            }

            createWavData(pcmSamples, sampleRate) {
                const byteLength = pcmSamples.length * 2;
                const buffer = new ArrayBuffer(44 + byteLength);
                const view = new DataView(buffer);
                
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + byteLength, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, byteLength, true);
                
                let offset = 44;
                for (let i = 0; i < pcmSamples.length; i++) {
                    view.setInt16(offset, pcmSamples[i], true);
                    offset += 2;
                }
                
                return new Uint8Array(buffer);
            }

            async testConnection() {
                const testPCM = new Array(16000).fill(0); // 1 second of silence
                const wavData = this.createWavData(testPCM, 16000);
                
                const uploadResponse = await fetch(`${this.baseUrl}/upload`, {
                    method: 'POST',
                    headers: {
                        'authorization': this.apiKey,
                        'content-type': 'application/octet-stream'
                    },
                    body: wavData
                });

                if (!uploadResponse.ok) {
                    throw new Error(`API test failed: ${uploadResponse.status}`);
                }

                return 'AssemblyAI API connection successful!';
            }
        }

        let decoder = new ADPCMDecoder();
        let transcriptionService = null;

        function saveApiKey() {
            const apiKey = document.getElementById('apiKey').value;
            if (!apiKey.trim()) {
                alert('Please enter a valid API key');
                return;
            }
            
            transcriptionService = new TranscriptionService(apiKey);
            localStorage.setItem('assemblyai_key', apiKey);
            
            const results = document.getElementById('testResults');
            results.innerHTML = '<div class="result">‚úÖ API key saved successfully!</div>';
        }

        function testADPCM() {
            const testData = new Uint8Array([0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0]);
            const result = decoder.decodeBlock(testData);
            
            const output = `üß™ ADPCM Decoder Test Result:

üìä Input: ${testData.length} ADPCM bytes
üìä Output: ${result.length} PCM samples
üìä Sample Rate: 16kHz (estimated)
üìä Duration: ${(result.length / 32000).toFixed(3)}s

üéµ First PCM samples: ${result.slice(0, 8).join(', ')}

‚úÖ ADPCM decoder is working correctly!
This is the same decoder used in the mobile app.`;

            const results = document.getElementById('testResults');
            results.innerHTML = '<div class="result">' + output + '</div>';
        }

        async function testTranscription() {
            if (!transcriptionService) {
                alert('Please set AssemblyAI API key first');
                return;
            }

            const results = document.getElementById('testResults');
            results.innerHTML = '<div class="result">üß™ Testing AssemblyAI connection...</div>';

            try {
                const result = await transcriptionService.testConnection();
                results.innerHTML = '<div class="result">‚úÖ ' + result + '\n\nüéâ Transcription service is ready!\nThis is the same service used in the mobile app.</div>';
            } catch (error) {
                results.innerHTML = '<div class="result">‚ùå Transcription test failed:\n' + error.message + '</div>';
            }
        }

        // Load saved API key
        window.onload = function() {
            const saved = localStorage.getItem('assemblyai_key');
            if (saved) {
                document.getElementById('apiKey').value = saved;
                transcriptionService = new TranscriptionService(saved);
            }
        };
    </script>
</body>
</html>